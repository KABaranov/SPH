# time_integrator

В SPH-кодах обычно встречаются несколько классических схем интегрирования во времени — от простейших до более точных. Вот краткий обзор и рекомендации по выбору:

---

## 1. Прямой (явный) Эйлер

```python
vⁿ⁺¹ = vⁿ + aⁿ · Δt  
rⁿ⁺¹ = rⁿ + vⁿ · Δt
```

* **Плюсы:** очень просто; мало операций.
* **Минусы:** только первый порядок по Δt, большая ошибка фазирования, может быть неустойчив при «жёстких» силах.
* **Когда применять:** исключительно для тестовых или учебных задач, когда точность не критична и Δt очень мал.

---

## 2. Полуугловой (или полуступенчатый) Эйлер (Euler–Cromer)

```python
vⁿ⁺¹ = vⁿ + aⁿ · Δt  
rⁿ⁺¹ = rⁿ + vⁿ⁺¹ · Δt
```

* **Плюсы:** немного более устойчивый, лучше сохраняет энергию при осцилляциях.
* **Минусы:** всё ещё первый порядок.
* **Когда применять:** простые свободно падающие тела, простейшие демодвижки со слабой жёсткостью.

---

## 3. Predictor–Corrector (двухшаговый)

```python
# Predictor
v* = vⁿ + aⁿ · Δt  
r* = rⁿ + vⁿ · Δt  
# Recompute a* = a(r*, v*)  
# Corrector
vⁿ⁺¹ = vⁿ + ½(aⁿ + a*)·Δt  
rⁿ⁺¹ = rⁿ + ½(vⁿ + v*)·Δt
```

* **Плюсы:** второй порядок по Δt; хорошо балансирует точность и стоимость.
* **Минусы:** надо дважды считать силы (в predictor и в corrector).
* **Когда применять:** универсальный выбор для СПH-кодов — умеренная цена и приличная точность.

---

## 4. Verlet / Leapfrog

```python
# Leap-frog (“скачущий квакер”)
vⁿ⁺¹ᐟ₂ = vⁿ⁻¹ᐟ₂ + aⁿ · Δt  
rⁿ⁺¹   = rⁿ + vⁿ⁺¹ᐟ₂ · Δt
```

* **Плюсы:** второй порядок; легко реализуется; хорошая энергия- и момент-сохранность; стабильнее при жёстких силах.
* **Минусы:** нужно хранить «половинные» скорости; чуть сложнее в связке с вычислением плотности (ρ) и давлений (Р).
* **Когда применять:** динамика с жёсткими взаимодействиями, ударные волны, гравитационные расчёты — в SPH-кодах часто используют именно leapfrog.

---

## 5. Runge–Kutta (RK2, RK4)

```python
# RK2 (midpoint):
k1 = f(tⁿ, yⁿ)
k2 = f(tⁿ + Δt/2, yⁿ + k1·Δt/2)
yⁿ⁺¹ = yⁿ + k2·Δt
```

* **Плюсы:** высокая точность (2-й порядок для RK2, 4-й для RK4); контроллируемая ошибка.
* **Минусы:** много вызовов f(…) = «вычислить accelerations»; дорого в SPH, где каждая оценка требует поиска соседей.
* **Когда применять:** когда критична точность по времени и вы готовы заплатить за много поиска соседей и пересчёта сил, например при валидации на сильных нестационарных потоках.

---

### Как выбрать

1. **Учебная или быстрая проверка** → явный Эйлер / Euler–Cromer.
2. **Баланс точности/стоимости** → Predictor–Corrector (2-й порядок).
3. **Жёсткие силы / хорошая сохранность энергии** → Verlet / Leapfrog.
4. **Очень высокая временная точность** → RK-семейство (но дорого).

В SPH-кодах чаще всего берут **leapfrog** или **predictor–corrector**: они дают второй порядок, устойчивы и относительно недороги.
